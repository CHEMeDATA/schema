// ES module
import fs from "fs";
import path from "path";
import { schemaRoot, schemaDir, instanceDir } from "./config.js";

// Throw error helper
function generateError(message) {
	throw new Error("‚ùå " + message);
}

// Compact numeric arrays in JSON string, insert line breaks every lineLength chars
function compactNumericArrays(jsonString, lineLength = 100) {
	function processArray(content) {
		let depth = 0;
		let start = 0;
		let result = "";

		for (let i = 0; i < content.length; i++) {
			const char = content[i];
			if (char === "[") {
				if (depth === 0) start = i;
				depth++;
			} else if (char === "]") {
				depth--;
				if (depth === 0) {
					const inner = content.slice(start + 1, i);
					const compactedInner = processArray(inner);
					result += `[${compactedInner}]`;
					continue;
				}
			}

			if (depth === 0) result += char;
		}

		const items = result.split(",").map((s) => s.trim());
		const allNumbers = items.every(
			(item) => !isNaN(Number(item)) && item !== ""
		);
		if (allNumbers) {
			const joined = items.join(", ");
			let final = "";
			for (let i = 0; i < joined.length; i += lineLength) {
				final += joined.slice(i, i + lineLength) + "\n";
			}
			return final.trim();
		}

		return result;
	}

	let stack = [];
	let output = "";
	let startIdx = null;

	for (let i = 0; i < jsonString.length; i++) {
		const char = jsonString[i];
		if (char === "[") {
			if (stack.length === 0) startIdx = i;
			stack.push("[");
		} else if (char === "]") {
			stack.pop();
			if (stack.length === 0 && startIdx !== null) {
				const content = jsonString.slice(startIdx + 1, i);
				const compacted = processArray(content);
				output += `[${compacted}]`;
				startIdx = null;
				continue;
			}
		}

		if (stack.length === 0 && char !== "]") {
			output += char;
		}
	}

	return output;
}

// Ensure derivations.json file exists
function ensureDerivationsFile(derivationsFile) {
	if (!fs.existsSync(derivationsFile)) {
		const initialData = {
			_comment: "This file is automatically generated. Do not edit manually.",
			derivations: [],
		};
		fs.writeFileSync(
			derivationsFile,
			JSON.stringify(initialData, null, 4),
			"utf8"
		);
	}
}

// Add derivation record
function addDerivation(derivationsFile, base, derived, fieldsToAdd) {
	ensureDerivationsFile(derivationsFile);
	const content = JSON.parse(fs.readFileSync(derivationsFile, "utf8"));
	content.derivations.push({ base, derived, fieldsToAdd });
	fs.writeFileSync(derivationsFile, JSON.stringify(content, null, 4), "utf8");
}

// Derive a schema
export function deriveSchema(sourceClass, derivedClass, fieldsToAdd) {
	const sourcePath = path.join(schemaDir, `${sourceClass}.json`);
	const derivedPath = path.join(schemaDir, `${derivedClass}.json`);
	const derivationsFile = path.join(".", "derivations.json");

	addDerivation(derivationsFile, sourceClass, derivedClass, fieldsToAdd);

	console.log(`üõ†Ô∏è Deriving ${sourceClass} into ${derivedClass}...`);
	console.log(
		`   Adding fields:`,
		fieldsToAdd
			.map((f) => `${f.name} (${f.type})${f.mandatory ? " [mandatory]" : ""}`)
			.join(", ")
	);

	const sourceSchema = JSON.parse(fs.readFileSync(sourcePath, "utf8"));

	const derivedSchema = {
		$schema: sourceSchema["$schema"],
		type: sourceSchema["type"],
		$id: `${schemaRoot}${derivedClass}.json`,
		allOf: [{ $ref: sourceSchema["$id"] }],
		properties: {},
	};

	const requiredFields = [];
	fieldsToAdd.forEach((field) => {
		derivedSchema["properties"][field.name] = { type: field.type };
		if (field.type === "float")
			derivedSchema["properties"][field.name] = { type: "number" };
		if (field.type === "double")
			derivedSchema["properties"][field.name] = { type: "number" };
		if (field.mandatory) {
			requiredFields.push(field.name);
		}
	});

	// Add required fields if any
	if (requiredFields.length > 0) {
		derivedSchema["required"] = requiredFields;
	}

	fs.writeFileSync(derivedPath, JSON.stringify(derivedSchema, null, 4));
	console.log(`‚úÖ ${derivedClass} schema created at:`, derivedPath);
}



/**
 * Create a JSON Schema based on provided properties
 * @param {string} newSchemaName - The name of the new schema (without .json)
 * @param {Array} propertiesList - An array defining properties with attributes
 */
export function createNewTypeSchema(newSchemaName, propertiesList) {
	if (!newSchemaName || !propertiesList) {
		generateError("Missing required parameters");
	}
	const schemaPath = path.join(schemaDir, `${newSchemaName}.json`);
	console.log(`üõ†Ô∏è Creating schema: ${newSchemaName}...`);

	const properties = {};
	const requiredFields = [];

	propertiesList.forEach((prop) => {
		let propSchema;
		if (prop.array) {
			if (prop.type === "object" && prop.ref) {
				propSchema = {
					type: "array",
					items: { $ref: `${schemaRoot}${prop.ref}.json` },
				};
			} else {
				// Regular array of basic types
				propSchema = { type: "array", items: { type: prop.type } };
				if (prop.type === "float")
					propSchema = { type: "array", items: { type: "number" } };
				if (prop.type === "double")
					propSchema = { type: "array", items: { type: "number" } };
			}
		} else {
			// Single objects or primitives
			if (prop.type === "object" && prop.ref) {
				propSchema = { $ref: `${schemaRoot}${prop.ref}.json` };
			} else {
				propSchema = { type: prop.type };
				if (prop.type === "float") propSchema = { type: "number" };
				if (prop.type === "double") propSchema = { type: "number" };
			}
		}

		properties[prop.name] = propSchema;

		if (prop.required) {
			requiredFields.push(prop.name);
		}
	});

	const newSchema = {
		$schema: "http://json-schema.org/draft-07/schema#",
		type: "object",
		$id: `${schemaRoot}${newSchemaName}.json`,
		properties: properties,
		required: requiredFields.length > 0 ? requiredFields : undefined,
	};

	fs.writeFileSync(schemaPath, JSON.stringify(newSchema, null, 4));
	console.log(`‚úÖ ${newSchemaName} schema created at:`, schemaPath);
}

// Create instance
export function createInstance(objName, schemaName, dataInput) {
	if (typeof dataInput === "string") {
		dataInput = dataInput.replace(
			/_INSERT_FILE-([\w.-]+)/g,
			(match, fileName) => {
				const filePath = path.join(instanceDir, fileName + ".json");
				try {
					const fileContent = fs.readFileSync(filePath, "utf-8");
					return fileContent;
				} catch (err) {
					console.error(`‚ö†Ô∏è Could not read file: ${filePath}`, err);
					return `"ERROR: missing file ${fileName}"`;
				}
			}
		);

		try {
			dataInput = JSON.parse(dataInput);
		} catch (err) {
			console.error("Invalid JSON string:", err.message);
			throw new Error("‚ùå ");
		}
	}

	if (!schemaName || !objName || !dataInput)
		generateError("Missing required parameters");

	const instancePath = path.join(instanceDir, `${objName}.json`);
	const data = {
		$schema: `${schemaRoot}${schemaName}.json`,
		wildComment:
			"Created by schema/scripts/createSchemaSomeInstances.js using function createInstance",
		...dataInput,
	};

	const constString = JSON.stringify(data, null, 4);
	const constString2 = compactNumericArrays(constString);
	fs.writeFileSync(instancePath, constString2);

	console.log(`‚úÖ ${objName} instance created at:`, instancePath);
}
