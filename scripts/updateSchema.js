const fs = require("fs");
const path = require("path");

// Directories
const schemaDir = "v1/schema";
//const schemaRoot = `https://raw.githubusercontent.com/CHEMeDATA/schema/main/${schemaDir}/`;
const schemaRoot = `https://chemedata.github.io/schema/${schemaDir}/`;

function ensureDerivationsFile(derivationsFile) {
	if (!fs.existsSync(derivationsFile)) {
		const initialData = {
			_comment: "This file is automatically generated. Do not edit manually.",
			derivations: [],
		};
		fs.writeFileSync(
			derivationsFile,
			JSON.stringify(initialData, null, 4),
			"utf8"
		);
	}
}

// Add a derivation record
function addDerivation(derivationsFile, base, derived) {
	ensureDerivationsFile(derivationsFile);
	const content = JSON.parse(fs.readFileSync(derivationsFile, "utf8"));

	content.derivations.push({ base, derived });

	fs.writeFileSync(derivationsFile, JSON.stringify(content, null, 4), "utf8");
}

/**
 * Function to derive a new schema from an existing one
 * @param {string} sourceClass - The base schema filename (without `.json`)
 * @param {string} derivedClass - The new schema filename (without `.json`)
 * @param {Array} fieldsToAdd - Fields to add with properties { name, mandatory, type }
 */
function deriveSchema(sourceClass, derivedClass, fieldsToAdd) {
	const sourcePath = path.join(schemaDir, `${sourceClass}.json`);
	const derivedPath = path.join(schemaDir, `${derivedClass}.json`);

	// store in derivations file
	const derivationsFile = path.join(".", "derivations.json");
    addDerivation(derivationsFile, sourceClass, derivedClass);
	// Ensure file exists with _comment and empty derivations array

	console.log(`🛠️ Deriving ${sourceClass} into ${derivedClass}...`);
	console.log(
		`   Adding fields:`,
		fieldsToAdd
			.map((f) => `${f.name} (${f.type})${f.mandatory ? " [mandatory]" : ""}`)
			.join(", ")
	);

	// Load the source schema
	const sourceSchema = JSON.parse(fs.readFileSync(sourcePath, "utf8"));

	// Create the new schema based on the source schema
	const derivedSchema = {
		$schema: sourceSchema["$schema"],
		type: sourceSchema["type"],
		$id: `${schemaRoot}${derivedClass}.json`,
		allOf: [{ $ref: sourceSchema["$id"] }],
		properties: {},
	};

	// Add new fields
	const requiredFields = [];
	fieldsToAdd.forEach((field) => {
		derivedSchema["properties"][field.name] = { type: field.type };
		if (field.mandatory) {
			requiredFields.push(field.name);
		}
	});

	// Add required fields if any
	if (requiredFields.length > 0) {
		derivedSchema["required"] = requiredFields;
	}

	// Save the new schema
	fs.writeFileSync(derivedPath, JSON.stringify(derivedSchema, null, 4));

	console.log(`✅ ${derivedClass} schema created at:`, derivedPath);
}

/**
 * Create a JSON Schema based on provided properties
 * @param {string} newSchemaName - The name of the new schema (without .json)
 * @param {Array} propertiesList - An array defining properties with attributes
 */
function createNewTypeSchema(newSchemaName, propertiesList) {
	const schemaPath = path.join(schemaDir, `${newSchemaName}.json`);

	console.log(`🛠️ Creating schema: ${newSchemaName}...`);

	// Construct properties & required fields
	let properties = {};
	let requiredFields = [];

	propertiesList.forEach((prop) => {
		let propSchema;

		if (prop.array) {
			// Handle arrays
			if (prop.type === "object" && prop.ref) {
				// If it's an array of objects, use a reference
				propSchema = {
					type: "array",
					items: { $ref: `${schemaRoot}${prop.ref}.json` },
				};
			} else {
				// Regular array of basic types
				propSchema = { type: "array", items: { type: prop.type } };
			}
		} else {
			// Single objects or primitives
			if (prop.type === "object" && prop.ref) {
				propSchema = { $ref: `${schemaRoot}${prop.ref}.json` };
			} else {
				propSchema = { type: prop.type };
			}
		}

		properties[prop.name] = propSchema;

		if (prop.required) {
			requiredFields.push(prop.name);
		}
	});

	// Define the new schema
	const newSchema = {
		$schema: "http://json-schema.org/draft-07/schema#",
		type: "object",
		$id: `${schemaRoot}${newSchemaName}.json`,
		properties: properties,
		required: requiredFields.length > 0 ? requiredFields : undefined,
	};

	// Save the new schema
	fs.writeFileSync(schemaPath, JSON.stringify(newSchema, null, 4));
	console.log(`✅ ${newSchemaName} schema created at:`, schemaPath);
}

// Example usage
//createGroupSchema("groupObject1", [
//    { name: "members", required: true, array: true, type: "object", ref: "obj1" }, // Correctly reference obj1.json
//    { name: "groupSize", required: true, array: false, type: "number" },  // A required number field
//    { name: "active", required: false, array: false, type: "boolean" }   // An optional boolean field
//]);

// Example usage

createNewTypeSchema("obj1", [
	{ name: "name", required: true, array: false, type: "string" },
	{ name: "age", required: false, array: false, type: "integer" },
]);

createNewTypeSchema("obj2", [
	{ name: "name", required: true, array: false, type: "string" },
	{ name: "age", required: true, array: false, type: "integer" },
]);

deriveSchema("obj1", "obj1size", [
	{ name: "size", mandatory: true, type: "number" },
]);

createNewTypeSchema("groupObject1", [
	{ name: "members", required: true, array: true, type: "object", ref: "obj1" },
]);

createNewTypeSchema("sample", [
	{
		name: "origin",
		required: false,
		array: false,
		type: "object",
		ref: "sample",
	},
	// { name: "dateSHoulsBeHereNotSUre", required: false, array: false, type: "string"}
]);

deriveSchema("sample", "liquidSample", [
	{ name: "volume_L", mandatory: true, type: "number" },
]);

deriveSchema("liquidSample", "NMRliquidSample", [
	{ name: "tubeDiameter_mm", mandatory: true, type: "string" },
]);



createNewTypeSchema("pairObj1", [
	{
		name: "object1",
		required: true,
		array: false,
		type: "object",
		ref: "obj1",
	},
	{
		name: "object2",
		required: true,
		array: false,
		type: "object",
		ref: "obj2",
	}
	// { name: "dateSHoulsBeHereNotSUre", required: false, array: false, type: "string"}
]);